Пусть у нас есть программа, открывающая файл и вызывающая fork(). Два процесса одновременно записывают и читают один и тот же файл.
В коде открываются два файла - один для чтения, другой для записи, а также применяется одновременное чтение и запись parent и child.
Необходимо выяснить, что произойдёт, если оба процесса попытаются читать или записывать.



int main(void) {
 
        int fd_in,  fd_out;
        char buf[1024];
 
        memset(buf,  0,  1024);
        fd_in = open("/tmp/infile",  O_RDONLY);
        fd_out = open("/tmp/outfile",  O_WRONLY|O_CREAT);
 
        fork();
 
        while (read(fd_in,  buf,  2) > 0) { 
                printf("%d: %s",  getpid(),  buf);
                /* Написать строку */
                sprintf(buf,  "%d Hello,  world!\n\r",  getpid());
                write(fd_out,  buf,  strlen(buf));
                sleep(1);
                memset(buf,  0,  1024);
        }
        sleep(10);
}
 
mark$ gcc fdtest1.c -o fdtest1
mark$ ./fdtest1
2875: 1
2874: 2
2875: 3
2874: 4
2875: 5
2874: 6
2874: 7
mark$ cat /tmp/outfile
2875 Hello, world!
2874 Hello, world!
2875 Hello, world!
2874 Hello, world!
2875 Hello, world!
2874 Hello, world!
2874 Hello, world!


Когда процесс дублируется, ядро создает копии всех дескрипторов открытых файлов.
Дескриптор файла - это целое число, которое является ссылкой на открытый файл или устройство, и используется для чтения и записи.

Каждый процесс использует для чтения один и тот же дескриптор файла (текстовый файл с числами от 1 до 7), печатая то, что было прочитано вместе с PID.
После прочтения строки PID записывается в выходной файл (out file).
Цикл завершается, когда в файле больше не остается непрочитанных символов.
Результаты работы кода показывают, что, когда один процесс читает из файла, указатель файла смещается для обоих процессов.
Также, когда файл записывается, каждый следующий символ добавляется в конец файла.
Это имеет смысл, поскольку ядро отслеживает информацию об открытом файле.
Дескриптор файла это просто идентификатор для процесса.
